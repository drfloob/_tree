<!DOCTYPE html>

<html>
<head>
  <title>_tree.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>_tree.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/*
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.  
*/</span>

<span class="hljs-comment">/* jshint -W071 */</span>
<span class="hljs-comment">/* global define */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p><a href="https://github.com/umdjs/umd/blob/master/returnExports.js">UMD/returnExports.js</a>
setup for AMD, Node.js, and Global usages.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(root, factory)</span> {</span>
<span class="hljs-pi">    'use strict'</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>AMD. Register as an anonymous module.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        define([<span class="hljs-string">'underscore'</span>], factory);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports === <span class="hljs-string">'object'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Node. Does not work with strict CommonJS, but
only CommonJS-like enviroments that support module.exports,
like Node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-comment">/* global module, require */</span>
        module.exports = factory(<span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>));
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Browser globals (root is window)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        root._tree = factory(root._);
    }
}(<span class="hljs-keyword">this</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(_)</span> {</span>
<span class="hljs-pi">    'use strict'</span>;

    <span class="hljs-keyword">var</span> _tree = {}, Tree, Node, __defaults;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__callback</span><span class="hljs-params">(tree, event)</span> {</span>
        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">2</span>);
        _.each(tree.defaults.callbacks[event], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cb)</span> {</span>
            _.partial(cb, tree).apply(<span class="hljs-literal">null</span>, args);
        });
    }


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__preFinalizeTree</span><span class="hljs-params">(tree)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>engage mixins before calling the tree pre-finalized</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        _.each(tree.defaults.mixins, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(mix)</span> {</span>
            <span class="hljs-keyword">if</span> (mix.tree) {
                _.each(mix.tree, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(f, key)</span> {</span>
                    tree[key] = f;
                });
            }
            <span class="hljs-keyword">if</span> (mix.node) {
                _.each(mix.node, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(f, key)</span> {</span>
                    tree.walk(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(visitNode)</span> {</span>
                        visitNode[key] = f;
                    });
                });
            }
        });

        __setupAncestry(tree);
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Since tree and nodes are not set until this point, a
meaningful ancestry needs to be setup here at this last
step.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__setupAncestry</span><span class="hljs-params">(tree, node, parent)</span> {</span>
        <span class="hljs-keyword">if</span> (!node) {
            node = tree.root();
        }
        node.__tree = tree;
        <span class="hljs-keyword">if</span> (parent) {
            node.__parent = parent;
        }

        _.each(node.children(), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(c)</span> {</span>__setupAncestry(tree, c, node); });
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Before returning a mutable cloned tree, it needs to be properly
frozen to maintain its immutability guarantee. Also, since
trees aren’t immutable until all node modifications are done,
all nodes need to be given this last-stage reference to the
tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__finalizeMutableTreeClone</span><span class="hljs-params">(tree)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Environments that don’t support <code>Object.freeze</code> will still
work, but without guaranteed tree immutability.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> { <span class="hljs-built_in">Object</span>.freeze(tree); } <span class="hljs-keyword">catch</span> (e) {}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>finalizeMutableChildNodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        tree.walk(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> {</span>
            <span class="hljs-keyword">try</span> {
                <span class="hljs-built_in">Object</span>.freeze(node);
                <span class="hljs-built_in">Object</span>.freeze(node.__children);
            } <span class="hljs-keyword">catch</span> (e) {}
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>call each afterUpdate callback with the new tree</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        __callback(tree, <span class="hljs-string">'afterUpdate'</span>);
    }


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__cloneDefaults</span><span class="hljs-params">(defaults)</span> {</span>
        defaults = defaults ? _.clone(defaults) : {};
        defaults.callbacks = _.defaults(_.clone(defaults.callbacks || {}), __defaults.callbacks);
        defaults.mixins = _.union((defaults.mixins || []), __defaults.mixins);
        defaults = _.defaults(defaults, __defaults);
        <span class="hljs-keyword">return</span> defaults;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h1 id="public-api">Public API</h1>

            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p><code>_tree.inflate</code> parses tree-like data into an immutable <code>Tree</code>
object for you to work with. It does so without modifying your
object whatsoever, and it can handle any tree data structure
you define.</p>
<p>You can specify the default behaviour of your tree via the
<code>defaults</code> argument. Anything you don’t specify will take the
standard default options.</p>
<p><code>_tree.inflate</code> handles all forms of tree-like data by making
the object parsing logic fully pluggable. You can define your
own <code>inflateMethod</code>, or use one of the handful of built-ins.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _tree.inflate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj, inflateMethod, defaults)</span> {</span>
        defaults = __cloneDefaults(defaults);
        inflateMethod = defaults.inflate = inflateMethod || defaults.inflate;

        <span class="hljs-keyword">var</span> tree = <span class="hljs-keyword">new</span> Tree(defaults, obj, inflateMethod);
        __preFinalizeTree(tree);
        __callback(tree, <span class="hljs-string">'beforeFreeze'</span>);
        __finalizeMutableTreeClone(tree);
        <span class="hljs-keyword">return</span> tree;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p><code>_tree.create</code> creates an empty tree from scratch. Tree-wide
<code>defaults</code> can also be set here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _tree.create = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(defaults)</span> {</span>
        <span class="hljs-keyword">return</span> _tree.inflate(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, defaults);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Maybe the most natural representation of trees in Javascript
can be parsed by this <code>_tree.inflate</code> method. It inflates
objects that have child arrays bound to some property of the
parent object (usually ‘children’)</p>
<p>For example, it parses an object like this:</p>
<pre><code>{<span class="hljs-string">'name'</span>: parent, 
 <span class="hljs-string">'children'</span>: [
     {<span class="hljs-string">'name'</span>: <span class="hljs-string">'child1'</span>}, 
     {<span class="hljs-string">'name'</span>: <span class="hljs-string">'child2'</span>, <span class="hljs-string">'children'</span>: [
         {<span class="hljs-string">'name'</span>: <span class="hljs-string">'child3'</span>}]
     }]
}
</code></pre><p>into a tree like this:</p>
<pre><code>parent
    child1
    child2
        child3
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    _tree.inflate.byKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Key)</span> {</span>
        Key = Key || <span class="hljs-string">'children'</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Obj)</span> {</span>
            <span class="hljs-keyword">this</span>.emit(Obj);
            <span class="hljs-keyword">if</span> (_.has(Obj, Key)) {
                <span class="hljs-keyword">this</span>.children(Obj[Key]);
            }
        };
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p><code>_tree.inflate.byAdjacencyList</code> parses a wonky sort of array,
wherein every entry is either a node, or an array containing
the children of the previous node. An example to clarify:</p>
<p>It parses an array like this:</p>
<pre><code>[<span class="hljs-string">'parent'</span>, [<span class="hljs-string">'child1'</span>, <span class="hljs-string">'child2'</span>, [<span class="hljs-string">'child3'</span>]]]
</code></pre><p>into a tree like this:</p>
<pre><code>parent
    child1
    child2
        child3
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    _tree.inflate.byAdjacencyList = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Obj)</span> {</span>
        <span class="hljs-keyword">var</span> kids, tmpObj, i;
        <span class="hljs-keyword">this</span>.emit(_.first(Obj));
        <span class="hljs-keyword">if</span> (Obj.length &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (!_.isArray(Obj[<span class="hljs-number">1</span>]) || Obj.length &gt; <span class="hljs-number">2</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-string">'invalid adjacency list'</span>;
            }
            kids = Obj[<span class="hljs-number">1</span>];
            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; kids.length; i++) {
                tmpObj = [kids[i]];
                <span class="hljs-keyword">if</span> (kids.length &gt; <span class="hljs-number">1</span> &amp;&amp; _.isArray(kids[i + <span class="hljs-number">1</span>])) {
                    tmpObj.push(kids[i + <span class="hljs-number">1</span>]);
                    i++;
                }
                <span class="hljs-keyword">this</span>.children([tmpObj]);
            }
        }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>If your tree only keeps data for leaf nodes, you can use <code>_tree.inflate.onlyLeavesList</code>
inflation method to parse arrays like this:</p>
<pre><code>[[child1, [child3]]]
</code></pre><p>into trees like this:</p>
<pre><code>&lt;no data&gt;
    child1
    &lt;no data&gt;
        child3
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    _tree.inflate.onlyLeavesList = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Obj)</span> {</span>
        <span class="hljs-keyword">if</span> (!_.isArray(Obj) || Obj.length &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-string">'invalid leaves list'</span>;
        }
        <span class="hljs-keyword">if</span> (_.isArray(_.first(Obj))) {
            <span class="hljs-keyword">this</span>.children(_.map(_.first(Obj), <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> {</span><span class="hljs-keyword">return</span> [n];}));
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.emit(_.first(Obj));
        }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p><code>_tree.fromNode</code>, allows the creation of a new tree from an
existing <code>Node</code>. The new tree is considered to <em>not</em> be a clone
of the node’s original tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _tree.fromNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(node, defaults)</span> {</span>
        <span class="hljs-keyword">if</span> (! (node <span class="hljs-keyword">instanceof</span> Node)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'invalid node: '</span> + <span class="hljs-built_in">JSON</span>.stringify(node));
        }
        defaults = __cloneDefaults(defaults);
        <span class="hljs-keyword">var</span> tree = <span class="hljs-keyword">new</span> Tree(defaults);
        tree.__root = Node.clone(tree, node);
        __preFinalizeTree(tree);
        __callback(tree, <span class="hljs-string">'beforeFreeze'</span>);
        __finalizeMutableTreeClone(tree);
        <span class="hljs-keyword">return</span> tree;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h1 id="tree">Tree</h1>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>This is the <code>Tree</code> constructor. It is intended to be used
internally, and so it returns a mutable object that must be
frozen before it’s returned. For the sake of IE8, and all other
environments that don’t support Object.definePropert(y|ies),
the nasty bit of try/catch here allows those environments to
work without guaranteed immutability.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(defaults, obj, inflateMethod, nextNodeId)</span> {</span>
        <span class="hljs-keyword">this</span>.defaults = defaults;
        <span class="hljs-keyword">var</span>  __id, __nextNodeId, __root;
        __id = _.uniqueId();
        __nextNodeId = nextNodeId || <span class="hljs-number">0</span>;
        <span class="hljs-keyword">try</span> {
            <span class="hljs-built_in">Object</span>.defineProperties(<span class="hljs-keyword">this</span>, {
                <span class="hljs-string">'__id'</span>: {
                    value: __id,
                    writable: <span class="hljs-literal">true</span>,
                    enumerable: <span class="hljs-literal">false</span>,
                    configurable: <span class="hljs-literal">false</span>
                },
                <span class="hljs-string">'__nextNodeId'</span>: {
                    value: __nextNodeId,
                    writable: <span class="hljs-literal">true</span>,
                    enumerable: <span class="hljs-literal">false</span>,
                    configurable: <span class="hljs-literal">false</span>
                },
                <span class="hljs-string">'__batch'</span>: {
                    value: <span class="hljs-number">0</span>,
                    writable: <span class="hljs-literal">true</span>,
                    enumerable: <span class="hljs-literal">false</span>,
                    configurable: <span class="hljs-literal">false</span>
                }
            });
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-keyword">this</span>.__id = __id;
            <span class="hljs-keyword">this</span>.__nextNodeId = __nextNodeId;
        }
        
        <span class="hljs-keyword">if</span> (!!obj &amp;&amp; !!inflateMethod) {
            __root = Tree.inflate(<span class="hljs-keyword">this</span>, obj, inflateMethod);
        } <span class="hljs-keyword">else</span> {
            __root = <span class="hljs-keyword">new</span> Node(<span class="hljs-keyword">this</span>);
        }

        <span class="hljs-keyword">try</span> {
            <span class="hljs-built_in">Object</span>.defineProperties(<span class="hljs-keyword">this</span>, {
                <span class="hljs-string">'__root'</span>: {
                    writable: <span class="hljs-literal">true</span>,
                    enumerable: <span class="hljs-literal">false</span>,
                    configurable: <span class="hljs-literal">false</span>,
                    value: __root
                }
            });
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-keyword">this</span>.__root = __root;
        }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <h2 id="internal-static-tree-methods">Internal Static Tree Methods</h2>

            </div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>To facilitate immutability, <code>Tree.clone</code> provides a static copy
constructor that takes a(n) (im)mutable tree and returns a
mutable clone. This method provides the base for all Tree
modifications.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.clone = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(tree)</span> {</span>
        <span class="hljs-keyword">var</span> newTree = <span class="hljs-keyword">new</span> Tree(tree.defaults);
        newTree.__root = Node.clone(newTree, tree.root());
        newTree.__nextNodeId = tree.__nextNodeId;
        newTree.__id = tree.__id;
        <span class="hljs-keyword">return</span> newTree;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p><code>Tree.inflate</code> provides the general logic behind object
inflation/parsing/deserialization.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.inflate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tree, obj, inflateMethod)</span> {</span>
        <span class="hljs-keyword">var</span> thisnode = <span class="hljs-keyword">new</span> Node(tree), _this;
        tree.__root = thisnode;</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>When <code>inflateMethod</code> is called to navigate <code>obj</code>, <code>this</code> is
bound to the following object:</p>
<ul>
<li><code>this.emit(data)</code>: Sets the data for the current node.</li>
<li><code>this.children([child])</code>: Calling this immediately
processes and inflates a set of child node objects.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>        _this = {
            emit: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Data)</span> {</span>
                thisnode.__data = Data;
            },
            children: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Nodes)</span> {</span>
                _.each(Nodes, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(kidObj)</span> {</span>
                    <span class="hljs-keyword">var</span> kidTree = <span class="hljs-keyword">new</span> Tree(tree.defaults, kidObj, inflateMethod, tree.__nextNodeId);
                    thisnode.__children.push(kidTree.root());
                    kidTree.root().__parent = thisnode;
                    tree.__nextNodeId = kidTree.__nextNodeId;
                });
            }
        };

        inflateMethod.call(_this, obj);
        <span class="hljs-keyword">return</span> thisnode;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h2 id="tree-instance-methods">Tree Instance Methods</h2>

            </div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>A getter for the root <code>Node</code> of the tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.root = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__root;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Find a node in a tree by internal id correlation, and return
the Node or <code>false</code> if no match was found. This can be used to
find a matching node in a cloned tree, since ids are designed
to be invariant across clones.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.findNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fromNode, walkMethod)</span> {</span>
        <span class="hljs-keyword">if</span> (! (fromNode <span class="hljs-keyword">instanceof</span> Node)) {
            <span class="hljs-keyword">throw</span> <span class="hljs-string">'not a node'</span>;
        }

        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.equals(fromNode.__tree)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

        <span class="hljs-keyword">var</span> found = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>.walk(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(visitNode)</span> {</span>
            <span class="hljs-keyword">if</span> (!found &amp;&amp; fromNode.equals(visitNode)) {
                found = visitNode;
            }
        }, walkMethod);
        <span class="hljs-keyword">return</span> found;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Matches a node by its data using deep comparison, without
requiring object equality, via <code>_.isEqual(node.data(), data)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.findNodeByData = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, walkMethod)</span> {</span>
        <span class="hljs-keyword">var</span> isMatch, keys, found = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (_.isUndefined(data)) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
        <span class="hljs-keyword">if</span> (_.isObject(data) &amp;&amp; !_.isArray(data)) {
            keys = _.keys(data);
            isMatch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nodeData)</span> {</span>
                <span class="hljs-keyword">if</span> (!_.isObject(nodeData) || _.isArray(nodeData)) {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                }
                <span class="hljs-keyword">return</span> _.isEqual(data, _.partial(_.pick, nodeData).apply(_, keys));
            };
        } <span class="hljs-keyword">else</span> {
            isMatch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nodeData)</span> {</span>
                <span class="hljs-keyword">return</span> _.isEqual(data, nodeData);
            };
        }

        <span class="hljs-keyword">this</span>.walk(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(visitNode)</span> {</span>
            <span class="hljs-keyword">if</span> (!found &amp;&amp; isMatch(visitNode.__data)) {
                found = visitNode;
            }
        }, walkMethod);
        <span class="hljs-keyword">return</span> found;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>This method is the workhorse of the library. It allows you to
walk the tree in arbitrary ways (specified by <code>walkMethod</code>), and
execute <code>Callback</code> for every node in the order you specify.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.walk = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Callback, walkMethod, startNode)</span> {</span>
        walkMethod = walkMethod || <span class="hljs-keyword">this</span>.defaults.walk;
        <span class="hljs-keyword">var</span> _this, qs = [], recurList = [], tmpNode;

        <span class="hljs-keyword">if</span> (startNode) {
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.containsNode(startNode)) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'startNode does not exist in the tree'</span>);
            }
        } <span class="hljs-keyword">else</span> {
            startNode = <span class="hljs-keyword">this</span>.root();
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>In <code>walkMethod</code>, <code>this</code> will be bound to the following
object. To see how it’s used, scan the built-in walk
methods below. Briefly, the binding provides:</p>
<ul>
<li><code>queue</code>: Adds nodes to the end of the callback list.</li>
<li><code>push</code>: Adds nodes to the front of the callback list.</li>
<li><code>recurse</code>: Recurses immediately on the set of nodes.</li>
<li><code>queueRecurse</code>: Adds a set of nodes to the end of a list of nodes to recurse on next.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>        _this = {

            <span class="hljs-string">'queue'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Nodes)</span> {</span>
                qs = qs.concat(Nodes);
            },
            <span class="hljs-string">'push'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Nodes)</span> {</span>
                qs = Nodes.concat(qs);
            },
            <span class="hljs-string">'recurse'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Nodes)</span> {</span>
                _.each(Nodes, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> {</span>
                    walkMethod.call(_this, n);
                });
            },
            <span class="hljs-string">'queueRecurse'</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Nodes)</span> {</span>
                recurList = recurList.concat(Nodes);
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Before executing any callbacks, an ordered list of nodes
(<code>qs</code>) is generated. In some cases, <code>walkMethod</code> many not be
able to evaluate all nodes in one pass, so <code>recurList</code> is
used to track which nodes to visit in the next pass.  It
can take as many passes as required.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        walkMethod.call(_this, startNode);
        <span class="hljs-keyword">while</span> (recurList.length &gt; <span class="hljs-number">0</span>) {
            tmpNode = recurList.shift();
            walkMethod.call(_this, tmpNode);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Finally, <code>Callback</code> is called for each node, in order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        _.each(qs, Callback);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>The is the implementation of the built-in depth-first,
pre-order traversal algorithm. It is setup as the default walk
method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.walk.dfpre = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Node)</span> {</span>
        <span class="hljs-keyword">this</span>.queue(Node);
        <span class="hljs-keyword">this</span>.recurse(Node.children());
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Depth-first, post-order traversal algorithm.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.walk.dfpost = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Node)</span> {</span>
        <span class="hljs-keyword">this</span>.recurse(Node.children());
        <span class="hljs-keyword">this</span>.queue(Node);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Breadth-first, pre-order traversal algorithm.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.walk.bfpre = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Node)</span> {</span>
        <span class="hljs-keyword">if</span> (!Node.parent()) {
            <span class="hljs-keyword">this</span>.queue([Node]);
        }
        <span class="hljs-keyword">this</span>.queue(Node.children());
        <span class="hljs-keyword">this</span>.recurse(Node.children());
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Breadth-first, post-order traversal algorithm.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.walk.bfpost = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Node)</span> {</span>
        <span class="hljs-keyword">if</span> (!Node.parent()) {
            <span class="hljs-keyword">this</span>.push([Node]);
        }
        <span class="hljs-keyword">this</span>.push(Node.children());
        <span class="hljs-keyword">var</span> rev = _.clone(Node.children());
        rev.reverse();
        <span class="hljs-keyword">this</span>.queueRecurse(rev);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Tests for equality of trees across clone
lines. Returns <code>boolean</code>, whether trees share any clone
lineage.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.equals = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(otherTree)</span> {</span>
        <span class="hljs-keyword">return</span> (otherTree <span class="hljs-keyword">instanceof</span> Tree) &amp;&amp; <span class="hljs-keyword">this</span>.__id === otherTree.__id;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>A shorthand method to test whether a <code>Node</code> exists in the
<code>Tree</code>. <code>someNode</code> can be from any tree clone.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.containsNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(someNode)</span> {</span>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.findNode(someNode) <span class="hljs-keyword">instanceof</span> Node);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>A shorthand method to test whether a node containing this data
exists in the <code>Tree</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.containsData = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(someData)</span> {</span>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.findNodeByData(someData) <span class="hljs-keyword">instanceof</span> Node);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Returns a new <code>Tree</code> created by </p>
<ul>
<li>deleting the <code>movingNode</code>, </li>
<li>finding the destination parent node in the new <code>Tree</code> context, and</li>
<li>adding the <code>movingNode</code> as a child</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.moveNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(movingNode, toParent)</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.batch()
            .findNode(movingNode).remove()
            .findNode(toParent)
            .addChildNode(movingNode)
            .end();
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Registers callbacks for tree events. Currently, <code>event</code> can
only be ‘afterUpdate’, and <code>callback</code> can either be a single
function or an array of functions.</p>
<p>Note that adding callbacks generates a new tree, much as any
other tree modification</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.on = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event, callback)</span> {</span>
        <span class="hljs-keyword">var</span> newTree, cb;
        newTree = Tree.clone(<span class="hljs-keyword">this</span>);
        cb = _.isArray(callback) ? callback : [callback];
        newTree.defaults.callbacks[event] = newTree.defaults.callbacks[event].concat(cb);
        __preFinalizeTree(newTree);
        __callback(newTree, <span class="hljs-string">'beforeFreeze'</span>);
        __finalizeMutableTreeClone(newTree);
        <span class="hljs-keyword">return</span> newTree;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Unregisters callbacks for tree events. Currently, <code>event</code> can
only be ‘afterUpdate’, and <code>callback</code> can either be a single
function or an array of functions. This also generates a new
tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.off = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event, callback)</span> {</span>
        <span class="hljs-keyword">var</span> newTree, cb;
        newTree = Tree.clone(<span class="hljs-keyword">this</span>);
        cb = _.isArray(callback) ? callback : [callback];
        newTree.defaults.callbacks[event] = _.partial(_.without, newTree.defaults.callbacks[event]).apply(_, cb);
        __preFinalizeTree(newTree);
        __callback(newTree, <span class="hljs-string">'beforeFreeze'</span>);
        __finalizeMutableTreeClone(newTree);
        <span class="hljs-keyword">return</span> newTree;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Adds mixin properties and functions to the tree. These mixins
are preserved across all tree operations. Be careful, you can
overwrite core _tree methods with mixins. No effort is made to
protect you there. Namespacing your mixins is probably good
practice.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Tree.prototype.mixin = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(mixin)</span> {</span>
        <span class="hljs-keyword">var</span> newTree;
        newTree = Tree.clone(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">if</span> (!_.contains(newTree.defaults.mixins, mixin)) {
            newTree.defaults.mixins.push(mixin);
        }
        __preFinalizeTree(newTree);
        __callback(newTree, <span class="hljs-string">'beforeFreeze'</span>);
        __finalizeMutableTreeClone(newTree);
        <span class="hljs-keyword">return</span> newTree;
    };




    Tree.prototype.batch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> batchTree;
        batchTree = Tree.clone(<span class="hljs-keyword">this</span>);
        batchTree.__batch++;
        <span class="hljs-keyword">return</span> batchTree;
    };

    Tree.prototype.isBatch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__batch &gt; <span class="hljs-number">0</span>;
    };

    Tree.prototype.end = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isBatch()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-string">'Called `tree.end` when not in batch mode.'</span>;
        }

        <span class="hljs-keyword">this</span>.__batch--;
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isBatch()) {
            __finalizeMutableTreeClone(<span class="hljs-keyword">this</span>);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <h1 id="node">Node</h1>

            </div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>This defines the <code>Node</code> constructor, and much like <code>Tree</code>, the
resulting object is mutable until just before being exposed to
the external world.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Node = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(tree)</span> {</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-built_in">Object</span>.defineProperties(<span class="hljs-keyword">this</span>, {
                <span class="hljs-string">'__tree'</span>: {
                    value: tree,
                    writable: <span class="hljs-literal">true</span>,
                    enumerable: <span class="hljs-literal">false</span>,
                    configurable: <span class="hljs-literal">false</span>
                },
                <span class="hljs-string">'__data'</span>: {
                    writable: <span class="hljs-literal">true</span>,
                    enumerable: <span class="hljs-literal">false</span>,
                    configurable: <span class="hljs-literal">false</span>
                },
                <span class="hljs-string">'__children'</span>: {
                    value: [],
                    writable: <span class="hljs-literal">true</span>,
                    enumerable: <span class="hljs-literal">false</span>,
                    configurable: <span class="hljs-literal">false</span>
                },
                <span class="hljs-string">'__id'</span>: {
                    value: tree.__nextNodeId,
                    writable: <span class="hljs-literal">true</span>,
                    enumerable: <span class="hljs-literal">false</span>,
                    configurable: <span class="hljs-literal">false</span>
                }
            });
        } <span class="hljs-keyword">catch</span> (e) {
            <span class="hljs-keyword">this</span>.__tree = tree;
            <span class="hljs-keyword">this</span>.__data = <span class="hljs-literal">undefined</span>;
            <span class="hljs-keyword">this</span>.__children = [];
            <span class="hljs-keyword">this</span>.__id = tree.__nextNodeId;
        }
        tree.__nextNodeId = tree.__nextNodeId + <span class="hljs-number">1</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>A static copy constructor for <code>Node</code> objects, much like
<code>Tree.clone</code>, but recursive. All child nodes are cloned as
well.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Node.clone = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(newTree, node, differentId)</span> {</span>
        <span class="hljs-keyword">var</span> newNode = <span class="hljs-keyword">new</span> Node(newTree);
        newNode.__data = node.__data;

        newNode.__children = _.map(node.children(), <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(c)</span> {</span> <span class="hljs-keyword">return</span> Node.clone(newTree, c, differentId); });
        _.each(newNode.__children, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(c)</span> {</span>c.__parent = newNode;});

        <span class="hljs-keyword">if</span> (!differentId) {
            newNode.__id = node.__id;
            newTree.__nextNodeId--;
        }

        <span class="hljs-keyword">return</span> newNode;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>The <code>Node.data</code> method is both a getter and setter, depending
on how it’s used.</p>
<p>If <code>Obj</code> isn’t submitted, it’s used as a getter.</p>
<p>Otherwise, it’s used as a setter. Setting the data on a node
triggers the creation of a complete tree clone. Modifications
are done to the mutable clone, and the entire tree is returned
after being made immutable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Node.prototype.data = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Obj)</span> {</span>

        <span class="hljs-keyword">if</span> (!Obj) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__data;
        }

        <span class="hljs-keyword">var</span> newTree, newNode;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tree().isBatch()) {
            <span class="hljs-keyword">this</span>.__data = Obj;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tree();
        }

        newTree = Tree.clone(<span class="hljs-keyword">this</span>.tree());
        newNode = newTree.findNode(<span class="hljs-keyword">this</span>);
        newNode.__data = Obj;

        __preFinalizeTree(newTree);
        __callback(newTree, <span class="hljs-string">'beforeFreeze'</span>);
        __callback(newTree, <span class="hljs-string">'beforeFreeze.data'</span>, newNode);
        __finalizeMutableTreeClone(newTree);
        <span class="hljs-keyword">return</span> newTree;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>A simple getter for node children.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Node.prototype.children = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__children;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>A simple getter for the node’s parent. Returns <code>undefined</code> if
no parent is set.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Node.prototype.parent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__parent;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>A simple getter for the node’s tree. <code>_tree</code> is intended for
internal use. Presumably, client code will know which tree a
node is in, but it may be useful to client code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Node.prototype.tree = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__tree;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>A simple getter for the node’s id. <code>__id</code> is intended for
internal use, but may also be valuable to client code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Node.prototype.id = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__id;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>To add a child node, an object representing the node data is
parsed as if it were a new tree and then appended to the end of
the children array. Remember that a newly-cloned tree is
returned, <em>not</em> a <code>Node</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Node.prototype.parseAndAddChild = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(childObj, inflateMethod)</span> {</span>
        inflateMethod = inflateMethod || <span class="hljs-keyword">this</span>.__tree.defaults.inflate;
        <span class="hljs-keyword">var</span> childTree, newTree, newNode, tree;
        tree = <span class="hljs-keyword">this</span>.tree();
        childTree = <span class="hljs-keyword">new</span> Tree(tree.defaults, childObj, inflateMethod, tree.__nextNodeId);

        <span class="hljs-keyword">if</span> (tree.isBatch()) {
            <span class="hljs-keyword">this</span>.__children.push(childTree.root());
            tree.__nextNodeId = childTree.__nextNodeId;
            __preFinalizeTree(tree);
            <span class="hljs-keyword">return</span> tree;
        }

        newTree = Tree.clone(tree);
        newNode = newTree.findNode(<span class="hljs-keyword">this</span>);
        newNode.__children.push(childTree.root());
        newTree.__nextNodeId = childTree.__nextNodeId;

        __preFinalizeTree(newTree);
        __callback(newTree, <span class="hljs-string">'beforeFreeze'</span>);
        __callback(newTree, <span class="hljs-string">'beforeFreeze.parseAndAddChild'</span>, childTree.root());
        __finalizeMutableTreeClone(newTree);

        <span class="hljs-keyword">return</span> newTree;
    };



    Node.prototype.addChildNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node)</span> {</span>
        <span class="hljs-keyword">var</span> newTree, newParentNode, nodeClone;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tree().isBatch()) {
            nodeClone = Node.clone(<span class="hljs-keyword">this</span>.tree(), node, <span class="hljs-literal">true</span>);
            <span class="hljs-keyword">this</span>.__children.push(nodeClone);
            __preFinalizeTree(<span class="hljs-keyword">this</span>.tree());
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tree();
        }

        newTree = Tree.clone(<span class="hljs-keyword">this</span>.tree());
        newParentNode = newTree.findNode(<span class="hljs-keyword">this</span>);

        newTree.__nextNodeId = <span class="hljs-keyword">this</span>.tree().__nextNodeId;
        nodeClone = Node.clone(newTree, node, <span class="hljs-literal">true</span>);
        newParentNode.__children.push(nodeClone);

        __preFinalizeTree(newTree);
        __callback(newTree, <span class="hljs-string">'beforeFreeze'</span>);
        __callback(newTree, <span class="hljs-string">'beforeFreeze.addChildNode'</span>, nodeClone);
        __finalizeMutableTreeClone(newTree);

        <span class="hljs-keyword">return</span> newTree;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p><code>Node.equals</code> works across clone lines, determining if both
nodes <em>represent</em> the same node regardless of whether they’re
the same object in memory.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    Node.prototype.equals = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(otherNode)</span> {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.__tree.equals(otherNode.__tree) &amp;&amp;
            <span class="hljs-keyword">this</span>.__id === otherNode.__id;
    };

    Node.prototype.remove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> === <span class="hljs-keyword">this</span>.tree().root()) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'cannot delete the root node'</span>);
        }

        <span class="hljs-keyword">var</span> newTree, newNode, parNode;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tree().isBatch()) {
            parNode = <span class="hljs-keyword">this</span>.parent();
            parNode.__children = _.without(parNode.__children, <span class="hljs-keyword">this</span>);
            __preFinalizeTree(<span class="hljs-keyword">this</span>.tree());
            <span class="hljs-keyword">return</span> parNode.tree();
        }


        newTree = Tree.clone(<span class="hljs-keyword">this</span>.__tree);
        newNode = newTree.findNode(<span class="hljs-keyword">this</span>);
        parNode = newTree.findNode(<span class="hljs-keyword">this</span>.__parent);

        parNode.__children = _.without(parNode.__children, newNode);
        __preFinalizeTree(newTree);
        __callback(newTree, <span class="hljs-string">'beforeFreeze'</span>);
        __callback(newTree, <span class="hljs-string">'beforeFreeze.remove'</span>, parNode);
        __finalizeMutableTreeClone(newTree);

        <span class="hljs-keyword">return</span> newTree;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Finally, we setup some library-wide defaults.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    __defaults =  {
        <span class="hljs-string">'inflate'</span>: _tree.inflate.byKey(),
        <span class="hljs-string">'walk'</span>: Tree.prototype.walk.dfpre,
        <span class="hljs-string">'deleteRecursive'</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-string">'callbacks'</span>: {<span class="hljs-string">'afterUpdate'</span>: [],
                      <span class="hljs-string">'beforeFreeze'</span>: [],
                      <span class="hljs-string">'beforeFreeze.data'</span>: [],
                      <span class="hljs-string">'beforeFreeze.parseAndAddChild'</span>: [],
                      <span class="hljs-string">'beforeFreeze.addChildNode'</span>: [],
                      <span class="hljs-string">'beforeFreeze.remove'</span>: []
                     },
        <span class="hljs-string">'mixins'</span>: []
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>And we’re done.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> _tree;
}));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
